---
title: 工程化
order: 9
---

这个提案不是目前才提出来的，但基于目前情况(**大前提**)，疫情四起，
所有公司都在开源节流，这个方面开始大火，所以工程化被提上日程，所以还是专门开个
题，学习一下。

## peerDependencies
同等依赖，或者叫同伴依赖，用于指定当前包（也就是你写的包）兼容的宿主版本。用于解决插件与所依赖包不一致的问题。

- dependencies 是你的项目所依赖的包。
- devDependencies 是开发阶段所需要的包。比如说像 Jest 这样的测试框架或 Babel、ESLint 等其他库。

在以上两种情况中，当你安装一个包时，其 dependencies 和 devDependencies 会被 npm 自动安装。
- peerDependencies 则有所不同，它们不会被自动安装。
当一个依赖项 c 被列在某个包 b 的 peerDependency 中时，它就不会被自动安装。取而代之的是，包含了 b 包的代码库 a 则必须将对应的依赖项 c 包含为其依赖。

[peerDependencies](https://segmentfault.com/a/1190000022435060)

## Pnpm/npm/varn 有什么区别？有什么特点？
### npm/varn 

在 npm1、npm2 中呈现出的是嵌套结构,会导致3个问题：
1. 依赖层级太深，会导致文件路径过长的问题，尤其在 window 系统下；
2. 大量重复的包被安装，文件体积超级大。比如跟 foo 同级目录下有一个baz，两者都依赖于同一个版本的lodash，那么 lodash 会分别在两者的 node_modules 中被安装，也就是重复安装；
3. 模块实例不能共享。比如 React 有一些内部变量，在两个不同包引入的 React 不是同一个模块实例，因此无法共享内部变量，导致一些不可预知的 bug；

从 npm3 开始，包括 yarn，都着手来通过扁平化依赖的方式来解决上面的这个问题：

所有的依赖都被拍平到node_modules目录下，不再有很深层次的嵌套关系。这样在安装新的包时，根据 node require 机制，会不停往上级的node_modules当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。

但是扁平化带来了新的问题：
1. package.json里并没有写入的包竟然也可以在项目中使用了(Phantom - 幻影依赖)。
2. node_modules安装的不稳定性（Doppelgangers - 分身依赖）。
3. 平铺式的node_modules算法复杂，耗费时间。

### pnpm - 基于符号链接的node_modules结构
pnpm(Performance npm)的作者Zoltan Kochan发现 yarn 并没有打算去解决上述的这些问题，于是另起炉灶，写了全新的包管理器。

pnpm复刻了npm所有的命令，所以使用方法和npm一样，并且在安装目录结构上做了优化，特点是善用链接，且由于链接的优势，大多数情况下pnpm的安装速度比yarn和npm更快。

### npm/yarn 与 pnpm 对比小结
- npm/yarn - 缺点

1. 扁平的node_modules结构允许访问没有引用的package。
1. 来自不同项目的package不能共享，这是对磁盘空间的消耗。
1. 安装缓慢，大量重复安装node_modules。

- pnpm - 解决方案

1. pnpm使用独创的基于symlink的node_modules结构，只允许访问package.json中的引入packages（严格）。
1. 安装的package存储在一个任何文件夹都可以访问的目录里并用硬连接到各个node_modules，以节省磁盘空间（高效）。
1. 有了上述改变，安装也会更快（快速）。

## monorepo 是什么？有什么优势？如何落地？
针对微服务代码的仓库组织，业界一直有两种主要的实践：

1. 一种是多仓库（multi-repo），在微服务中就是每个服务一个源码仓库。
1. 另一种叫单体仓库（mono-repo），虽然应用采用的微服务架构，但将所有源码放在同一个仓库。

### 多仓库（multi-repo）
多仓库为我们带来了如下好处：

1. 每一个服务都有一个独立的仓库，职责单一。
1. 代码量和复杂性受控，服务由不同的团队独立维护、边界清晰。
1. 单个服务也易于自治开发测试部署和扩展，不需要集中管理集中协调。
1. 利于进行权限控制，可以针对单个仓库来分配权限，权限分配粒度比较细。
但同时，多仓库也存在着以下的问题：

1. 项目代码不容易规范。每个团队容易各自为政，随意引入依赖，code review 无法集中开展，代码风格各不相同。
1. 项目集成和部署会比较麻烦。虽然每个项目服务易于集成和部署，但是整个应用集成和部署的时候由于仓库分散就需要集中的管理和协调。
1. 开发人员缺乏对整个项目的整体认知。开发人员一般只关心自己的服务代码，看不到项目整体，造成缺乏对项目整体架构和业务目标整体性的理解。
1. 项目间冗余代码多。每个服务一个服务一个仓库，势必造成团队在开发的时候走捷径，不断地重复造轮子而不是去优先重用其他团队开发的代码。

### 单体仓库（mono-repo）
单体仓库的优势：
1. 易于规范代码。所有的代码在一个仓库当中就可以标准化依赖管理，集中开展 code review，规范化代码的风格。
1. 易于集成和部署。所有的代码在一个仓库里面，配合自动化构建工具，可以做到一键构建、一键部署，一般不需要特别的集中管理和协调。
1. 易于理解项目整体。开发人员可以把整个项目加载到本地的 IDE 当中，进行 code review，也可以直接在本地部署调试，方便开发人员把握整体的技术架构和业务目标。
1. 易于重用。所有的代码都在一个仓库中，开发人员开发的时候比较容易发现和重用已有的代码，而不是去重复造轮子，开发人员（通过 IDE 的支持）容易对现有代码进行重构，可以抽取出一些公共的功能进一步提升代码的质量和复用度。

单体仓库的劣势：
1. 单体仓库基本放弃了对读权限的限制，开发人员可以接触到项目所有代码，Bilibili 的源代码泄露也印证了这个问题。
1. 对于写权限，单体仓库也是有着自己的解决方案，比如 OWNERS，CODEOWNERS 等，但相比多仓库还是差了一些。
1. 单个服务的开发测试部署和扩展，需要集中管理集中协调，降低了微服务单个服务的自治程度。
1. 代码量和复杂性不受控，随着公司业务团队规模的变大，单一的代码库会变得越来越庞大复杂性也呈极度的上升，容易受团队能力及开发流程等影响导致结果不可控。
1. 想要玩转单体仓库，一般需要独立的代码管理和集成团队进行支持，加上配套的自动化构建工具来支持。某些方面已经出现了开源的方案，比如 Google 自研的面向单体仓库的构建工具 Bazel：https://bazel.build/ 和 Facebook 的 Buck：https://buck.build/ 。但还是需要团队进行整合。

## CommonJS、AMD、CMD、ES Module 一文流
时间轴：CommonJS --> AMD --> CMD --> ES Module

### CommonJS
- 常用于：服务器端，node，webpack
- 特点：同步/运行时加载，磁盘读取速度快
- 语法：
```
// 1. 导出：通过module.exports或exports来暴露模块
module.exports = {
  attr1,
  attr2
}
exports.attr = xx

**注意**
不可以 exports = xxx，这样写会无效，因为更改了exports的地址
而 exports 是 module.exports 的引用指向的是同一个内存，模块最后导出的是module.exports

// 2. 引用：require('x')

const xx = require('xx') // 整体重命名
const { attr } = require('xx') // 解构某一个导出
```

[参考文档](https://segmentfault.com/a/1190000041871312?utm_source=sf-similar-article)

### AMD
- 常用于：不常用，CommonJs的浏览器端实现
- 特点：
    - 异步加载：因为面向浏览器端，为了不影响渲染肯定是异步加载
    - 依赖前置：所有的依赖必须写在最初的依赖数组中，速度快，但是会浪费资源，预先加载了所有依赖不管你是否用到
- 语法：
```
// 1. 导出：通过define来定义模块
// 如果该模块还依赖其他模块，则将模块的路径填入第一个参数的数组中

define(['x'], function(x){  
  function foo(){  
      return x.fn() + 1  
  }  
  return {    
      foo: foo  
  };
});

// 2. 引用
require(['a'], function (a){
  a.foo()
});
```

### CMD
- 常用于：不常用，根据CommonJs和AMD实现，优化了加载方式
- 特点：
    - 异步加载
    - 按需加载/依赖就近：用到了再引用依赖，方便了开发，缺点是速度和性能较差
- 语法：
```
// 1. 导出：通过define来定义模块
// 如果该模块还依赖其他模块，在用到的地方引用即可

define(function(){  
  function foo(){        
      var x = require('x')
      return x.fn() + 1  
  }  
  return {    
      foo: foo  
  };
});

// 2. 引用
var x = require('a');
a.foo();
```

### ES module
- 常用于：目前浏览器端的默认标准
- 特点：静态编译： 在编译的时候就能确定依赖关系，以及输入和输出的变量
- 语法：
```
// 1. 导出：通过export 或 export default 输出模块
写法1: 边声明，边导出
export var m = 1;
export function m() {};
export class M {};

写法2：导出一个接口 export {}，形似导出对象但不是, 本质上是引用集合，最常用的导出方法
export {
  attr1,
  attr2
}

写法3：默认导出 
export default fn

// 2. 引用
import { x } from 'test.js' // 导出模块中对应的值，必须知道值在模块中导出时的名字
import { x as myx } from 'test.js' // 改名字
import x from 'test.js' // 默认导出的引用方式
```
